# HOW OUTPUT IS CHOSEN

## Step 1: Collect Active Nodes
```c
for (all nodes) {
    if (node->state > threshold &&     // Node is activated
        node->energy > cost &&          // Has enough energy
        node->token_len > 0) {          // Has data
        
        candidates[i] = node
        score[i] = frequency * token_len  // SCORING!
    }
}
```

## Step 2: Sort by Score
```c
// Higher score = more likely to output
score = frequency * token_len

Examples:
  "cat": freq=20, len=3 → score=60
  "ca":  freq=30, len=2 → score=60
  "c":   freq=40, len=1 → score=40
```

## Step 3: Filter Substrings
```c
// If "cat" is chosen, skip "ca" and "c" (substrings)
for (each candidate) {
    if (this is substring of higher-ranked candidate)
        skip it
}
```

## Step 4: Output Best Tokens
```c
// Output top N non-overlapping tokens
output(top_tokens)
```

## THE PROBLEM:

Scoring is: `frequency * token_len`

This means:
- Frequent short tokens (like "ve") score HIGH
- Rare long tokens (like "fourteen") score LOW

So when input is "seven":
- "ve" activates (freq=6, len=2, score=12)
- "seven" activates (freq=1, len=5, score=5)
- "twelve" activates (from connections, freq=1, len=6, score=6)

WINNER: "ve" and "twelve" (higher scores!)
LOSER: "fourteen" (not even created yet!)

## THE FIX NEEDED:

Scoring should favor:
1. RECENTLY ACTIVATED (recency matters!)
2. STRONGLY CONNECTED (propagation strength)
3. LONG TOKENS (compression bonus)

Not just frequency!
