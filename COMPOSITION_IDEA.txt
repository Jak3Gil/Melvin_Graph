# COMPOSITION - The Key to Abstraction

## Current Problem:
Similarity connects similar TOKENS
But doesn't discover STRUCTURE

## The Answer: COMPOSITIONAL NODES

### Level 1: Atomic tokens
```
Node 0: "1"
Node 1: "+"
Node 2: "2"
Node 3: "3"
Node 4: "4"
```

### Level 2: Compositions (sequences of nodes!)
```
Node 5: [0,1,0] = "1+1"    (refers to nodes 0,1,0)
Node 6: [2,1,2] = "2+2"    (refers to nodes 2,1,2)
Node 7: [3,1,3] = "3+3"    (refers to nodes 3,1,3)
```

### Level 3: Pattern discovery!
```
Notice: Nodes 5,6,7 all have structure [X,1,X]
Create: Node 8: [*,1,*] = "N+N" pattern (abstract!)
```

## How This Works:

### Input: "1+1=2"
1. Create atomic nodes: "1", "+", "2"
2. Create composite: [1,+,1,=,2]
3. Check similarity to existing composites
4. None exist → this is new pattern

### Input: "2+2=4"  
1. REUSE atomic nodes: "2", "+"
2. Create composite: [2,+,2,=,4]
3. Check similarity to [1,+,1,=,2]
   - Structure matches: [N,+,N,=,M]
   - Create abstract pattern node!

### Input: "3+3"
1. REUSE atomic: "3", "+"
2. Match pattern: [N,+,N]
3. PREDICT based on pattern: [N,+,N,=,2N]
4. Output: "6" (from abstraction!)

## The New Node Structure:

```c
typedef struct {
    uint8_t token[64];      // If atomic
    uint8_t token_len;
    
    uint32_t composition[16];  // If composite (refs to other nodes)
    uint8_t composition_len;
    
    uint8_t is_pattern;     // Has wildcards/placeholders
    
    float state, energy;
} Node;
```

## The New Rules:

1. REUSE atoms when possible
2. CREATE composites from sequences  
3. CONNECT similar structures (not just similar tokens!)
4. ABSTRACT when structures repeat (create pattern nodes)

## Result:

Complexity EMERGES from composition!
- Atoms combine into composites
- Composites with similar structure → patterns
- Patterns = abstraction = intelligence

This is how:
  "1+1=2" + "2+2=4" → learns "N+N=2N"
  
Not from similarity alone, but from COMPOSITIONAL SIMILARITY!
