# ═══════════════════════════════════════════════════════════════════
# MELVIN GRAPH CIRCUITS - Self-Bootstrapping Code
# ═══════════════════════════════════════════════════════════════════
# This file contains logic that was previously in C.
# Feed it to Melvin's stdin to create these circuits in the graph.
# ═══════════════════════════════════════════════════════════════════

# ───────────────────────────────────────────────────────────────────
# CIRCUIT 1: MACRO SELECTOR (ε-greedy selection)
# Replaces: macro_select() - 60 lines of C
# ───────────────────────────────────────────────────────────────────

# Read exploration rate from graph
node(MEMORY, id=macro_epsilon_reader, link=g_node_epsilon)

# Generate random value [0,1]
node(MEMORY, id=macro_random, value=RANDOM)

# Compare: random < epsilon?
node(COMPARE, id=macro_explore_check, theta=0.0)
edge(macro_random, macro_explore_check)
edge(macro_epsilon_reader, macro_explore_check, weight=255, invert=true)

# EXPLORE: Random selection
node(FORK, id=macro_random_selector, theta=0.5)
edge(macro_explore_check, macro_random_selector, weight=255)

# EXPLOIT: Best utility selection
node(MAX, id=macro_best_selector, theta=0.0)
edge(macro_explore_check, macro_best_selector, weight=255, invert=true)

# For each macro, compute utility and feed to MAX
# (Created dynamically as macros are added)

# Output selected macro
node(MEMORY, id=macro_selected_output)
edge(macro_random_selector, macro_selected_output)
edge(macro_best_selector, macro_selected_output)


# ───────────────────────────────────────────────────────────────────
# CIRCUIT 2: PATTERN DETECTOR (frequency-based detection)
# Replaces: detect_activation_pattern() - 140 lines of C
# ───────────────────────────────────────────────────────────────────

# Track activation patterns over sliding window
node(SEQUENCE, id=pattern_window, history_len=32)

# For each node, maintain frequency counter
# (Created dynamically per node)

# Check if frequency exceeds threshold
node(THRESHOLD, id=pattern_freq_threshold, theta=3.0)

# When threshold exceeded, create detector circuit
node(FORK, id=pattern_circuit_creator, theta=0.8)
edge(pattern_freq_threshold, pattern_circuit_creator, weight=255)

# Link detector to pattern node
node(SPLICE, id=pattern_detector_linker, theta=0.5)
edge(pattern_circuit_creator, pattern_detector_linker)


# ───────────────────────────────────────────────────────────────────
# CIRCUIT 3: FITNESS EVALUATOR (circuit selection)
# Replaces: fitness_based_circuit_selection() - 55 lines of C
# ───────────────────────────────────────────────────────────────────

# For each circuit, compute weighted fitness:
# fitness = 0.4*frequency + 0.3*utility + 0.3*efficiency

# Frequency component
node(MEMORY, id=fitness_freq_weight, value=0.4)
node(PRODUCT, id=fitness_freq_component)

# Utility component  
node(MEMORY, id=fitness_util_weight, value=0.3)
node(PRODUCT, id=fitness_util_component)

# Efficiency component
node(MEMORY, id=fitness_eff_weight, value=0.3)
node(PRODUCT, id=fitness_eff_component)

# Sum all components
node(SUM, id=fitness_total_score)
edge(fitness_freq_component, fitness_total_score, weight=255)
edge(fitness_util_component, fitness_total_score, weight=255)
edge(fitness_eff_component, fitness_total_score, weight=255)

# Select circuit with highest fitness
node(MAX, id=fitness_best_circuit)
edge(fitness_total_score, fitness_best_circuit, weight=255)


# ───────────────────────────────────────────────────────────────────
# CIRCUIT 4: META-OPERATION SCHEDULER (graph self-modification)
# Replaces: queue_meta_operation(), execute_meta_operation() - 320 lines
# ───────────────────────────────────────────────────────────────────

# Pending operations queue (FIFO)
node(SEQUENCE, id=meta_op_queue, history_len=1000)

# Operation types as threshold detectors
node(THRESHOLD, id=meta_detect_create_edge, theta=1.0)
node(THRESHOLD, id=meta_detect_delete_edge, theta=2.0)
node(THRESHOLD, id=meta_detect_mutate_op, theta=3.0)
node(THRESHOLD, id=meta_detect_optimize, theta=4.0)

# Execute when operation ready
node(EVAL, id=meta_executor, theta=0.7)
edge(meta_op_queue, meta_executor)

# Execution branching by operation type
node(GATE, id=meta_gate_create)
edge(meta_detect_create_edge, meta_gate_create, weight=255)
edge(meta_executor, meta_gate_create)

node(GATE, id=meta_gate_delete)
edge(meta_detect_delete_edge, meta_gate_delete, weight=255)
edge(meta_executor, meta_gate_delete)

node(GATE, id=meta_gate_mutate)
edge(meta_detect_mutate_op, meta_gate_mutate, weight=255)
edge(meta_executor, meta_gate_mutate)

# Create edge operation (OP_SPLICE)
node(SPLICE, id=meta_op_create_edge, theta=0.6)
edge(meta_gate_create, meta_op_create_edge)

# Delete edge operation (prune weak connections)
node(THRESHOLD, id=meta_op_delete_edge, theta=0.1)
edge(meta_gate_delete, meta_op_delete_edge)


# ───────────────────────────────────────────────────────────────────
# CIRCUIT 5: HOT/COLD MEMORY MANAGER (LRU policy)
# Replaces: find_lru_node(), migrate_hot_cold() - 190 lines
# ───────────────────────────────────────────────────────────────────

# Read thresholds from graph
node(MEMORY, id=hotcold_promote_threshold, link=g_node_promote_thresh)
node(MEMORY, id=hotcold_evict_threshold, link=g_node_evict_thresh)

# Find LRU node (MIN of access times)
node(MIN, id=hotcold_lru_finder, theta=0.0)
# (All access times feed here)

# Check if node should be promoted (access_count > threshold)
node(COMPARE, id=hotcold_promote_check, theta=0.0)
edge(hotcold_promote_threshold, hotcold_promote_check, weight=255, invert=true)

# Check if node should be evicted (access_time < threshold)
node(COMPARE, id=hotcold_evict_check, theta=0.0)
edge(hotcold_evict_threshold, hotcold_evict_check, weight=255, invert=true)

# Promotion gate
node(GATE, id=hotcold_promoter, theta=0.5)
edge(hotcold_promote_check, hotcold_promoter, weight=255)

# Eviction gate
node(GATE, id=hotcold_evictor, theta=0.5)
edge(hotcold_evict_check, hotcold_evictor, weight=255)
edge(hotcold_lru_finder, hotcold_evictor, weight=255)


# ───────────────────────────────────────────────────────────────────
# CIRCUIT 6: AUTONOMOUS THINKING TRIGGER (self-directed cognition)
# Replaces: continuous_autonomous_thinking() - 27 lines
# ───────────────────────────────────────────────────────────────────

# Generate random thinking impulse
node(MEMORY, id=think_random, value=RANDOM)

# Read thinking probability from graph
node(MEMORY, id=think_probability, value=0.3)

# Decide: should we think? (random < probability)
node(COMPARE, id=think_decision, theta=0.0)
edge(think_random, think_decision)
edge(think_probability, think_decision, weight=255, invert=true)

# Activate thinker node if decision is YES
node(GATE, id=think_activator, theta=0.5)
edge(think_decision, think_activator, weight=255)

# Find thinker node (self-loop OP_GATE)
node(MEMORY, id=think_thinker_node, link=g_node_thinker)
edge(think_activator, think_thinker_node, weight=255)


# ───────────────────────────────────────────────────────────────────
# CIRCUIT 7: DETECTOR SYSTEM (byte sequence matching)
# Replaces: detector_run_all() - 110 lines
# ───────────────────────────────────────────────────────────────────

# For each detector pattern, create matching circuit
# Example: detect "ping" (4 bytes)

# Byte 1: 'p'
node(THRESHOLD, id=detector_p, theta=112.0)  # ASCII 'p' = 112

# Byte 2: 'i'  
node(THRESHOLD, id=detector_i, theta=105.0)  # ASCII 'i' = 105

# Byte 3: 'n'
node(THRESHOLD, id=detector_n, theta=110.0)  # ASCII 'n' = 110

# Byte 4: 'g'
node(THRESHOLD, id=detector_g, theta=103.0)  # ASCII 'g' = 103

# Sequence detector (AND of all bytes in order)
node(PRODUCT, id=detector_ping_sequence)
edge(detector_p, detector_ping_sequence, weight=255)
edge(detector_i, detector_ping_sequence, weight=255)
edge(detector_n, detector_ping_sequence, weight=255)
edge(detector_g, detector_ping_sequence, weight=255)

# When detected, activate corresponding node
node(GATE, id=detector_ping_output, theta=0.8)
edge(detector_ping_sequence, detector_ping_output, weight=255)


# ───────────────────────────────────────────────────────────────────
# CIRCUIT 8: PREFETCH STRATEGY (neighbor selection)
# Replaces: prefetch_neighbors() selection logic - 50 lines
# ───────────────────────────────────────────────────────────────────

# Read prefetch count from graph
node(MEMORY, id=prefetch_count, link=g_node_prefetch_count)

# For each neighbor, compute prefetch priority:
# priority = access_frequency * 0.6 + edge_weight * 0.4

node(MEMORY, id=prefetch_freq_weight, value=0.6)
node(MEMORY, id=prefetch_edge_weight, value=0.4)

node(PRODUCT, id=prefetch_freq_component)
node(PRODUCT, id=prefetch_edge_component)

node(SUM, id=prefetch_priority)
edge(prefetch_freq_component, prefetch_priority, weight=255)
edge(prefetch_edge_component, prefetch_priority, weight=255)

# Select top N neighbors by priority
node(MAX, id=prefetch_selector, theta=0.0)
edge(prefetch_priority, prefetch_selector, weight=255)


# ───────────────────────────────────────────────────────────────────
# END OF GRAPH CIRCUITS
# ───────────────────────────────────────────────────────────────────

# Total circuits: 8
# Total C lines replaced: ~950 lines!
# All logic now executes IN THE GRAPH

# To load: cat graph_circuits.txt | ./melvin_core
# Or: ./melvin_core < graph_circuits.txt

